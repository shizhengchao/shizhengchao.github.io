<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[布隆过滤器简单实现]]></title>
    <url>%2F2018%2F04%2F20%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[BitSet介绍BitSet的原理 Java BitSet可以按位存储，计算机中一个字节(byte)占8位(bit)；而BitSet是位操作的对象，值只有0或1（即true 和 false），内部维护一个long数组，初始化只有一个long segement，所以BitSet最小的size是64；随着存储的元素越来越多，BitSet内部会自动扩充，一次扩充64位，最终内部是由N个long segement 来存储；默认情况下，BitSet所有位都是0即false； BitSet的应用场景 海量数据去重、排序、压缩存储 BitSet的基本操作 and（与）、or（或）、xor（异或） BitSet的优缺点 优点：按位存储，内存占用空间小；丰富的api操作 缺点：线程不安全；BitSet内部动态扩展long型数组，若数据稀疏会占用较大的内存 long型数组作为内部存储结构 JDK选择long数组作为BitSet的内部存储结构是出于性能的考虑，在and和or的时候减少循环次数，提高性能；因为BitSet提供and和or这种操作，需要对两个BitSet中的所有bit位做and或者or，实现的时候需要遍历所有的数组元素。使用long能够使得循环的次数降到最低，所以Java选择使用long数组作为BitSet的内部存储结构。 举个例子： 当我们进行BitSet中的and, or, xor操作时，要对整个bitset中的bit都进行操作，需要依次读出bitset中所有的word，如果是long数组存储，我们可以每次读入64个bit,而int数组存储时，只能每次读入32个bit 布隆过滤器布隆过滤器原理 Bloom Filter是一个占用空间很小、效率很高的随机数据结构，它由一个bit数组和一组Hash算法构成。可用于判断一个元素是否在一个集合中。本身并不存储数据真实的值,而是把数据N 通过 K次映射函数f(hash)，把每次得到的值 V放入bit数组对应的索引位置，并把值设置为1。在判断是否存在时，只要判断每一次的映射对应的位都是1则可能存在(可能存在冲突，像哈希一样)，但如果只要有一个不为1，则一定不存在。原理图如下： 初始化一个位数组值全部为0 数据N经过K次映射函数f()得到的哈希值(f1,f2,f3,…fk)存入bit数组，对应的位设置成1 应用场景 网页爬虫对URL的去重，避免爬取相同的URL地址； 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）； 缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。 简单实现 实现布隆过滤器最主要的是映射函数的选择，思路就是将比较字符串问题变成一个比较数字的问题。常见的方法有： 各字符串的首字母和尾字母的编码之乘积 取奇数个字符的编码执行异或等。 用md5 下面使用md5来简单实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.BitSet;/** * @author shizhengchao * @version */public class SimpleBloomFilter &#123; private BitSet bs; public static final int NUM_SLOTS = 1024 * 1024 * 8; public static final int NUM_HASH = 8; public SimpleBloomFilter() &#123; bs = new BitSet(); &#125; public void add(String value) &#123; for (int i = 0; i &lt; NUM_HASH; i++) &#123; bs.set(getHash(value, i), true); &#125; &#125; /** * 可能存在 * @param value * @return * * @author shizhengchao * @version */ public boolean mightContains(String value) &#123; if (value == null || value.isEmpty()) &#123; return false; &#125; for (int i = 0; i &lt; NUM_HASH; i++) &#123; if (!bs.get(getHash(value, i))) &#123; return false; &#125; &#125; return true; &#125; private int getHash(String message, int n) &#123; try &#123; MessageDigest md5 = MessageDigest.getInstance("md5"); message = message + String.valueOf(n); byte[] bytes = message.getBytes(); md5.update(bytes); BigInteger bi = new BigInteger(md5.digest()); return Math.abs(bi.intValue()) % NUM_SLOTS; &#125; catch (NoSuchAlgorithmException ex) &#123; &#125; return -1; &#125; public BitSet getBs() &#123; return bs; &#125; public static void main(String[] args) &#123; SimpleBloomFilter bloomFilter = new SimpleBloomFilter(); bloomFilter.add("www.baidu.com"); bloomFilter.add("shizhengchao@outlook.com"); System.out.println(bloomFilter.mightContains("www.baidu.com")); System.out.println(bloomFilter.mightContains("tinny.cn")); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
        <tag>BitSet</tag>
        <tag>缓存穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式之枚举实现]]></title>
    <url>%2F2018%2F04%2F15%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[策略模式也叫作政策模式，定义一组算法，将每个算法都封装起来，并且使他们之间可以互换策略模式的使用就是面向对象的继承和多态机制,策略模式具有三个角色分别是： Context封装角色，也叫作上下文角色，屏蔽高层模块对策略、算法的直接访问，封装可能的变化。 Istrategy抽象策略角色，策略算法家族的抽象，通常为接口定义每个算法必须具有的方法和属性。 ConcreteStrategy具体策略角色，实现抽象策略中的操作该类含有具体的算法。 策略模式的一般实现使用起来不够简单，下面介绍两种枚举的实现方式 方式一 和普通策略模式一样，定义一个算法接口 123public interface Strategy &#123; int result(int a, int b);&#125; 创建一个枚举类CalculatorStrategies实现Strategy接口 123456789101112131415161718192021222324252627282930313233343536373839/** * @author shizhengchao * @version */enum CalculatorStrategies implements Strategy &#123; /** * 加法 */ ADD() &#123; @Override public int result(int a, int b) &#123; return a + b; &#125; &#125;, /** * 减法 */ SUB() &#123; @Override public int result(int a, int b) &#123; if(a &gt; b) &#123; return a - b; &#125; return b - a; &#125; &#125;, /** * 乘法 */ MULTI() &#123; @Override public int result(int a, int b) &#123; return a * b; &#125; &#125;&#125; 使用方式1234567public class MainTest &#123; public static void main(String[] args) &#123; System.out.println(CalculatorStrategies.ADD.result(5, 6)); System.out.println(CalculatorStrategies.SUB.result(10, 8)); System.out.println(CalculatorStrategies.ADD.result(5, 20)); &#125;&#125; 方式二这种方式不需要创建接口，直接使用一个枚举类即可,但是需要一个抽象方法，可以看出和方式一其实是一样的，只是方式一把接口分离出去，便于维护。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @author shizhengchao * @version */enum AnotherCalculatorStrategies &#123; /** * 加法 */ ADD &#123; @Override public int result(int a, int b) &#123; return a + b; &#125; &#125;, /** * 减法 */ SUB &#123; @Override public int result(int a, int b) &#123; if(a &gt; b) &#123; return a - b; &#125; return b - a; &#125; &#125;, /** * 乘法 */ MULTI &#123; @Override public int result(int a, int b) &#123; return a * b; &#125; &#125;; //需要一个抽象方法 public abstract int result(int a, int b);&#125; 总结使用枚举方式实现策略模式比一般的策略模式在用法上轻松了许多，思路也非常清晰。通过这种方式实现能给人一种极简的感觉，让(装)人(得)眼(一)前(手)一(好)亮(逼)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
        <tag>strategy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring+netty+protobuff实现rpc]]></title>
    <url>%2F2018%2F04%2F07%2Fspringboot-netty-protobuff%E5%AE%9E%E7%8E%B0rpc%2F</url>
    <content type="text"><![CDATA[前言RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络，把调用请求发到远程计算机程序上，远程程序再解析请求后，对服务请进调用。客户端在不必知道调用细节的前提之下，调用远程计算机上运行的某个对象，使用起来就像调用本地的对象一样。目前典型的RPC实现框架有：Thrift（facebook开源）、Dubbo（alibaba开源）等等。RPC框架针对网络协议、网络I/O模型的封装是透明的，对于调用的客户端而言，它就认为自己在调用本地的一个对象。至于传输层上，运用的是TCP协议、UDP协议、亦或是HTTP协议，一概不关心。从网络I/O模型上来看，是基于select、poll、epoll方式、还是IOCP（I/O Completion Port）方式承载实现的，对于调用者而言也不用关心。 知识点 netty spring protostuff java反射 aop 模型图 代码实现provider代码实现思路：服务端启动时初始化服务，把服务实例存放于map中，再启动netty服务对客户端请求的监听，根据请求寻找相应的接口实例，运用反射调用接口，返回结果给客户端 ServiceInitCore.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Map;import java.util.Map.Entry;import org.springframework.beans.BeansException;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;import com.szc.blog.provicer.thread.NettyStartupThread;import com.szc.blog.rpc.annonation.ProviderService;@Componentpublic class ServiceInitCore implements ApplicationContextAware, InitializingBean &#123; @Value("$&#123;netty.server.port&#125;") private int port; @Value("$&#123;netty.server.host&#125;") private String host; // // 所有提供的服务 // private Map&lt;String, Object&gt; serviceMap = new HashMap&lt;String, Object&gt;(); /** * 获取ProviderService的所有注解类,并放到map中 */ @Override public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123; ServiceHoldMap serviceHold = ServiceHoldMap.getInstance(); Map&lt;String, Object&gt; beansMap = ctx.getBeansWithAnnotation(ProviderService.class); for (Entry&lt;String, Object&gt; entry : beansMap.entrySet()) &#123; Class&lt;?&gt;[] c = entry.getValue().getClass().getInterfaces(); if (c == null || c.length == 0 || c.length &gt;= 2) &#123; continue; &#125; serviceHold.putService(c[0].getName(), entry.getValue()); &#125; &#125; @Override public void afterPropertiesSet() throws Exception &#123; Thread t = new Thread(new NettyStartupThread(host, port)); t.start(); &#125;&#125; ServiceHoldMap.java 1234567891011121314151617181920212223242526272829303132333435import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** *存放服务map * @author shizhengchao * @version */public class ServiceHoldMap &#123; private static final ServiceHoldMap instance = new ServiceHoldMap(); // 所有提供的服务 private Map&lt;String, Object&gt; serviceMap = new ConcurrentHashMap&lt;String, Object&gt;(); private ServiceHoldMap() &#123; &#125; public static ServiceHoldMap getInstance() &#123; return instance; &#125; public Map&lt;String, Object&gt; getServiceMap() &#123; return serviceMap; &#125; public void putService(String key, Object value) &#123; serviceMap.put(key, value); &#125; public Object getService(String key) &#123; return serviceMap.get(key); &#125;&#125; SubscribeServerHandler.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364mport io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.util.internal.logging.InternalLogger;import io.netty.util.internal.logging.InternalLoggerFactory;import org.apache.commons.lang3.reflect.MethodUtils;import com.szc.blog.rpc.message.Request;import com.szc.blog.rpc.message.Response;/** * 消息处理类 * * @author shizhengchao * @version */public class SubscribeServerHandler extends SimpleChannelInboundHandler&lt;Request&gt; &#123; private static final InternalLogger logger = InternalLoggerFactory.getInstance(SubscribeServerHandler.class); @Override protected void messageReceived(ChannelHandlerContext ctx, Request request) throws Exception &#123; logger.info("[Recieve request] &#123;&#125;", request.toString()); Response response = new Response(); response.setRequestId(request.getRequestId()); try &#123; Object result = handle(request); response.setResult(result); &#125; catch (Throwable t) &#123; response.setError(t.getMessage()); &#125; ctx.writeAndFlush(response); &#125; /** * 反射调用 * * @param request * @return * @throws Throwable */ private Object handle(Request request) throws Throwable &#123; ServiceHoldMap serviceHold = ServiceHoldMap.getInstance(); // 获取类名 String className = request.getClassName(); // 取出map里的实例 Object serviceBean = serviceHold.getService(className); // Class&lt;?&gt; serviceClass = serviceBean.getClass(); String methodName = request.getMethodName(); // Class&lt;?&gt;[] parameterTypes = request.getParameterTypes(); Object[] parameters = request.getParameters(); // 反射调用，返回结果 return MethodUtils.invokeMethod(serviceBean, methodName, parameters); &#125; /** * netty 消息异常捕获 */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; logger.error("server caught exception", cause.getMessage()); ctx.close(); &#125;&#125; NettyStartupThread.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import com.szc.blog.provicer.core.SubscribeServerHandler;import com.szc.blog.rpc.cdec.ProtostuffDecoder;import com.szc.blog.rpc.cdec.ProtostuffEncoder;import com.szc.blog.rpc.message.Request;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.LengthFieldBasedFrameDecoder;import io.netty.handler.codec.LengthFieldPrepender;/** * 使用线程异步去启动netty,能解决netty监听阻塞问题 * * @author shizhengchao * @version */public class NettyStartupThread implements Runnable &#123; private String host; private int port; public NettyStartupThread(String host, int port) &#123; this.host = host; this.port = port; &#125; @Override public void run() &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 100) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; // ByteBuf delimiter = // Unpooled.copiedBuffer("$_".getBytes()); // ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO)); ch.pipeline().addLast("frameDecoder", new LengthFieldBasedFrameDecoder(65535, 0, 2, 0, 2)); // 服务端是对request解码 ch.pipeline().addLast("proto decoder", new ProtostuffDecoder(Request.class)); ch.pipeline().addLast("frameEncoder", new LengthFieldPrepender(2)); // 服务端是对response编码 ch.pipeline().addLast("proto encoder", new ProtostuffEncoder()); ch.pipeline().addLast(new SubscribeServerHandler()); &#125; &#125;); ChannelFuture f = b.bind(host, port).sync(); f.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; bossGroup.shutdownGracefully(); workGroup.shutdownGracefully(); &#125; &#125;&#125; 源码地址直接上源码地址吧懒得写了: https://github.com/shizhengchao/netty-rpc]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis安装与开机启动]]></title>
    <url>%2F2018%2F03%2F27%2Fredis%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[安装 下载redis,并解压 12[root@izbp1311i2pe1xiq3x174lz opt]# http://download.redis.io/releases/redis-4.0.9.tar.gz[root@izbp1311i2pe1xiq3x174lz opt]# tar -zxvf redis-4.0.9.tar.gz 安装,源码安装后,src下的脚本文件会被复制到usr/local/bin下面 123456789101112[root@izbp1311i2pe1xiq3x174lz opt]# cd redis-4.0.9[root@izbp1311i2pe1xiq3x174lz redis-4.0.9]# make[root@izbp1311i2pe1xiq3x174lz redis-4.0.9]# make install CC Makefile.dep Hint: It&apos;s a good idea to run &apos;make test&apos; ;) INSTALL install INSTALL install INSTALL install INSTALL install INSTALL install 启动 12[root@izbp1311i2pe1xiq3x174lz redis-4.0.9]# cd src[root@izbp1311i2pe1xiq3x174lz src]# ./redis-server 后台启动把redis设置成服务，需要依赖redis-4.0.9/utils/redis_init_script脚本文件，打开脚本文件可以看到如下信息：12345678910111213141516171819202122#!/bin/sh## Simple Redis init.d script conceived to work on Linux systems# as it does use of the /proc filesystem.REDISPORT=6379EXEC=/usr/local/bin/redis-serverCLIEXEC=/usr/local/bin/redis-cliPIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pid #这里设置成需要的服务名.pid,比如redis.pidCONF=&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot;case &quot;$1&quot; in start) if [ -f $PIDFILE ] then echo &quot;$PIDFILE exists, process is already running or crashed&quot; else echo &quot;Starting Redis server...&quot; $EXEC $CONF fi ;; 按照脚本里的配置创建文件 首先把redis_init_script脚本复制到/etc/init.d/目录下 12[root@izbp1311i2pe1xiq3x174lz etc]# cp /opt/redis-4.0.9/utils/redis_init_script /etc/init.d/[root@izbp1311i2pe1xiq3x174lz init.d]# mv redis_init_script redis #这里重命名要与&quot;PIDFILE=/var/run/xxx.pid&quot; 里的xxx一致 创建/var/redis/6379文件夹 1234[root@izbp1311i2pe1xiq3x174lz ~]# cd /var[root@izbp1311i2pe1xiq3x174lz var]# mkdir redis[root@izbp1311i2pe1xiq3x174lz var]# cd redis[root@izbp1311i2pe1xiq3x174lz redis]# mkdir 6379 #和端口号一样的文件夹 创建/etc/redis/${REDISPORT}.conf 123[root@izbp1311i2pe1xiq3x174lz etc]# mkdir redis # 在/etc下创建redis文件夹[root@izbp1311i2pe1xiq3x174lz etc]# cp /opt/redis-4.0.9/redis.conf /etc/redis/[root@izbp1311i2pe1xiq3x174lz redis]# mv redis.conf 6379.cnf #并且重命名为6379.conf 检测开机启动(先检测是否支持开机启动) 123456789[root@izbp1311i2pe1xiq3x174lz ~]# cd /etc/init.d/[root@izbp1311i2pe1xiq3x174lz init.d]# chkconfig redis on #如果出现如下信息则不支持service redisd does not support chkconfig&lt;/pre&gt;使用vim编辑/etc/init.d/redis文件，在第一行加入如下两行注释，保存退出&lt;pre&gt;# chkconfig: 2345 90 10# description: Redis is a persistent key-value database注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。 再次执行开机启动命令 1234567[root@izbp1311i2pe1xiq3x174lz init.d]# chkconfig redis on 设置成功后，不可以使用service redis start/stop命令启动/停止redis了[root@izbp1311i2pe1xiq3x174lz init.d]# service redis startStarting Redis server...23297:C 19 Apr 23:13:45.149 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo23297:C 19 Apr 23:13:45.149 # Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=23297, just started23297:C 19 Apr 23:13:45.149 # Configuration loaded]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper安装与伪集群]]></title>
    <url>%2F2018%2F03%2F24%2Fzookeeper%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%AA%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[安装 下载最新版本的zookeeper [root@izbp1311i2pe1xiq3x174lz home]# wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz 解压zookeeper-3.4.10.tar.gz [root@izbp1311i2pe1xiq3x174lz home]# tar -zxvf zookeeper-3.4.10.tar.gz 进入到conf目录下配置zoo.cfg#ZooKeeper的最小时间单元,单位毫秒(ms),默认值为3000tickTime=2000#Leader服务器等待Follower启动并完成数据同步的时间,默认值10,表示tickTime的10倍initLimit=10#Leader服务器和Follower之间进行心跳检测的最大延时时间,默认值5,表示tickTime的5倍syncLimit=5#ZooKeeper服务器存储快照文件的目录,必须配值,建议放置在var目录下dataDir=/var/zookeeper1/datadataLogDir=/var/zookeeper1/logs#服务器对外服务端口,默认值为2181clientPort=2181 启动服务端 [root@izbp1311i2pe1xiq3x174lz bin]# sh zkServer.sh start 客户端连接 [root@izbp1311i2pe1xiq3x174lz bin]# sh zkCli.sh -server 127.0.0.1:2181 伪集群 解压三个zookeeper，分别重命名为zookeeper1、zookeeper2、zookeeper3 分别在zoo.cfg中加入如下配置clientPort=2181 #端口分别为2181、2182、2183server.1=127.0.0.1:2887:3887server.2=127.0.0.1:2888:3888server.3=127.0.0.1:2889:3889server.X=A:B:C, X代表第几号server，A是当前server的地址，B配置该server和集群中的leader交换消息所使用的端口. C配置选举leader时所使用的端口. 由于配置的是伪集群模式, 所以各个server的B, C参数必须不同 在第一个zookeeper的/var/zookeeper{num}/data目录下增加一个myid文件 [root@izbp1311i2pe1xiq3x174lz data]# touch myid [root@izbp1311i2pe1xiq3x174lz data]# vim myid #与入与server.x后面的x一样的数字，比如zookeeper1中就写入1. 到这里伪集群模式就配置好了，写一个批量启动和停止的shell脚本 1234567891011121314151617181920212223[root@izbp1311i2pe1xiq3x174lz zookeeper]# vim zookeeper_start.sh#!/bin/bash SERVERS=&quot;zookeeper1 zookeeper2 zookeeper3&quot; for SERVER in $SERVERS do echo &quot;当前&quot;$SERVER&quot;正在启动....................&quot; #ssh root@$SERVER &quot;source /etc/profile;/usr/apps/zookeeper-3.4.9/bin/zkServer.sh start&quot; sh /home/zookeeper/$SERVER/bin/zkServer.sh start echo $SERVER&quot;启动结束--------------------------------------------&quot; done [root@izbp1311i2pe1xiq3x174lz zookeeper]# vim zookeeper_stop.sh#!/bin/bash SERVERS=&quot;zookeeper1 zookeeper2 zookeeper3&quot; for SERVER in $SERVERS do echo &quot;当前&quot;$SERVER&quot;正在停止....................&quot; #ssh root@$SERVER &quot;source /etc/profile;/usr/apps/zookeeper-3.4.9/bin/zkServer.sh start&quot; sh /home/zookeeper/$SERVER/bin/zkServer.sh stop echo $SERVER&quot;停止结束--------------------------------------------&quot; done 启动集群服务 1[root@izbp1311i2pe1xiq3x174lz zookeeper]# sh zookeeper_start.sh]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>伪集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库更新大表数据结构解决方案]]></title>
    <url>%2F2018%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9B%B4%E6%96%B0%E5%A4%A7%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在不停止系统的情况下, 当需要对表进行ddl操作如加索引、增删列时，数据量小时直接在线修改表结构影响不大。但当表达到百万、千万数据就不能直接在线修改表结构,这样会拖跨整个数据库系统。一般的解决办法是新建一张原表，改好表结构后把原表数据导入新表，再修改表名。建议建议使用在线ddl工具，且在访问量少时进行。(在5.6版本之后，mysql支持online ddl方式，即某些DDL操作不会锁表) 具体过程 备份数据 mysql> select * from t_order into outfile 'D:/bak/order.txt'; 复制原表物理结构mysql&gt; create table t_order_bak like t_order; 执行表结构修改，比如增加索引 alter table `t_order_bak` add index (`a_index`); 把原表数据导入新表 mysql> insert into t_order_bak select * from t_order; 删除原表 drop table t_order; #可能你会担心，表删除后，应用程序会找不到表，但是一般系统都会有异常处理，而且我们会选择在凌晨处理 新表重命名原表 mysql> rename table t_order_bak to t_order;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA回调机制Callback]]></title>
    <url>%2F2018%2F03%2F13%2FJAVA%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6Callback%2F</url>
    <content type="text"><![CDATA[前言大家应该看过spring对jdbc和redis的代码，对JdbcTemplate和RedisTemplate两个类并不陌生，这两个框架中用到了大量的callback机制,因为不管在使用jdbc或者redis时，都需要先获取到这两个框架的客户端,比如jedis。比如这样的代码:12345678910111213141516171819202122232425262728293031323334353637public class JedisSpringDemo &#123; @Resource(name = "shardedJedisPool") private ShardedJedisPool shardedJedisPool; public String set(String key, String value)&#123; ShardedJedis shardedJedis = null; try&#123; // 从连接池中获取jedis分片对象 shardedJedis = shardedJedisPool.getResource(); // 设置值到redis中 return shardedJedis.set(key, value); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); &#125;finally &#123; if(null != shardedJedis)&#123; shardedJedis.close(); &#125; &#125; return null; &#125; public String get(String key)&#123; ShardedJedis shardedJedis = null; try&#123; // 从连接池中获取jedis分片对象 shardedJedis = shardedJedisPool.getResource(); // 设置值到redis中 return shardedJedis.set(key); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); &#125;finally &#123; if(null != shardedJedis)&#123; shardedJedis.close(); &#125; &#125; return null; &#125; &#125; 上面的这段代码违反了DRY原则，代码中的try，catch，finally中的绝大部分代码都是雷同的，唯一不同的就是我们return的那一行具体的调用方法，如果像这种方法很多的话(jedis提供了几十种类似的方法)，我们的代码重复率是很高的，代码重复率一旦高起来，相应的维护成本也会提高。 实现自己看了下java-design-patterns项目上的实现，但感觉看懂了，对于怎么应用还是没找到感觉，所以就自己再实现了一下，我模仿了spring对redis的实现来练习callback。例子的内容是通过callback来操作map的实现。 MapService.java:提供了map的一些基本操作1234567891011121314151617181920212223242526272829303132/** * 一些map的操作 * @author shizhengchao * @date 2018年2月13日 上午10:44:55 * @version */public class MapService &#123; private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); private static final MapService _instance = new MapService(); private MapService() &#123; &#125; public static MapService getInstance() &#123; return _instance; &#125; public String get(String key) &#123; return map.get(key); &#125; public String remove(String key) &#123; return map.remove(key); &#125; public Integer add(String key, String value) &#123; map.put(key, value); return map.size(); &#125;&#125; Callback.java:回调接口12345678910111213141516171819/** * 回调接口 * @author hz17052992 * @date 2018年3月29日 上午10:53:35 * @version */public interface Callback&lt;T&gt; &#123; /** * 回调方法 * @param service * @return * * @author shizhengchao * @date 2018年2月13日 上午10:44:55 * @version */ public T doCallback(MapService service);&#125; MapOperation.java:操作map类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 对Map的一些操作，这里是模仿spring对redis的封装，看spring对redis的源码中可以看到，用了大量的回调方法， * 大家应该对JdbcTemplate和RedisTemplate这两个类并不陌生，然后都知道，要操作jdbc或者是redis时都要先获取 * 相应的对象比如jedis * @author hz17052992 * @date 2018年3月29日 上午10:58:01 * @version */public class MapOperation &#123; /** * 向map中插入一个值 * @param key * @param value * @return * * @author shizhengchao * @date 2018年2月13日 上午10:44:55 * @version */ public Integer setValue(final String key, final String value) &#123; return execute(new Callback&lt;Integer&gt;() &#123; @Override public Integer doCallback(MapService service) &#123; return service.add(key, value); &#125; &#125;); &#125; public String getValue(final String key) &#123; return execute(new Callback&lt;String&gt;() &#123; @Override public String doCallback(MapService service) &#123; return service.get(key); &#125; &#125;); &#125; public String removeKey(final String key) &#123; return execute(new Callback&lt;String&gt;() &#123; @Override public String doCallback(MapService service) &#123; return service.remove(key); &#125; &#125;); &#125; /** * 可能这里看不出对代码的复用，我只是举例。比如说这里如果获取MapService对象比较复杂， 而且也是必须的，有必要把它封装到这里实现复用 * @param callback * @return * * @author hz17052992 * @date 2018年3月29日 上午11:48:49 * @version */ &lt;T&gt; T execute(Callback&lt;T&gt; callback) &#123; //do something return callback.doCallback(MapService.getInstance()); &#125;&#125; App.java:程序入口12345678910111213141516/** * @author shizhengchao * @date 2018年2月13日 上午10:44:55 * @version */public class App &#123; private static final Logger LOGGER = LoggerFactory.getLogger(App.class); public static void main(String[] args) &#123; MapOperation operation = new MapOperation(); Integer size = operation.setValue("redis", "good tool"); LOGGER.info("map size:&#123;&#125;", size); String ret = operation.getValue("redis"); LOGGER.info("redis is a &#123;&#125;", ret); &#125;&#125; 输出结果 14:27:30.059 [main] INFO com.szc.blog.callback.App - map size:1 14:27:30.065 [main] INFO com.szc.blog.callback.App - redis is a good tool 总结通过以上例子，应该对callback的利用有了一个大概的了解，可能我的例子当中，没有很好的体现出对代码的重用，比如在execute方法里就一行代码，获取MapService也比较简单。下面我们来看开头说的spring对redis的封装是如何玩转callback的RedisTemplate.class1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//...其它方法省略public &lt;T&gt; T execute(RedisCallback&lt;T&gt; action, boolean exposeConnection, boolean pipeline) &#123; Assert.isTrue(initialized, "template not initialized; call afterPropertiesSet() before using it"); Assert.notNull(action, "Callback object must not be null"); //这些全都是公共方法，封装到这里 RedisConnectionFactory factory = getConnectionFactory(); RedisConnection conn = null; try &#123; if (enableTransactionSupport) &#123; // only bind resources in case of potential transaction synchronization conn = RedisConnectionUtils.bindConnection(factory, enableTransactionSupport); &#125; else &#123; conn = RedisConnectionUtils.getConnection(factory); &#125; boolean existingConnection = TransactionSynchronizationManager.hasResource(factory); RedisConnection connToUse = preProcessConnection(conn, existingConnection); boolean pipelineStatus = connToUse.isPipelined(); if (pipeline &amp;&amp; !pipelineStatus) &#123; connToUse.openPipeline(); &#125; RedisConnection connToExpose = (exposeConnection ? connToUse : createRedisConnectionProxy(connToUse)); //调用回调方法 T result = action.doInRedis(connToExpose); // close pipeline if (pipeline &amp;&amp; !pipelineStatus) &#123; connToUse.closePipeline(); &#125; // TODO: any other connection processing? return postProcessResult(result, connToUse, existingConnection); &#125; finally &#123; if (!enableTransactionSupport) &#123; RedisConnectionUtils.releaseConnection(conn, factory); &#125; &#125; &#125; public &lt;T&gt; T execute(RedisCallback&lt;T&gt; action, boolean exposeConnection) &#123; return execute(action, exposeConnection, false); &#125; //举几个常用操作 public Boolean move(K key, final int dbIndex) &#123; final byte[] rawKey = rawKey(key); return execute(new RedisCallback&lt;Boolean&gt;() &#123; public Boolean doInRedis(RedisConnection connection) &#123; return connection.move(rawKey, dbIndex); &#125; &#125;, true); &#125; public K randomKey() &#123; byte[] rawKey = execute(new RedisCallback&lt;byte[]&gt;() &#123; public byte[] doInRedis(RedisConnection connection) &#123; return connection.randomKey(); &#125; &#125;, true); return deserializeKey(rawKey); &#125; 最后一句话总结：一些方法需要先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function），比如前面例子中的execute的参数(Callback callback)就是一个回调。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag> callback</tag>
        <tag>回调机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发量模拟]]></title>
    <url>%2F2018%2F03%2F11%2Fjava%E5%B9%B6%E5%8F%91%E9%87%8F%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[CountDownLatch能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。代码并发量测试，运用java concurrent包下的CountDownLatch模拟并发量。 await()方法 await方法让当前线程挂,直到计数器变成0 countDown()方法 countDown()方法计数器减1 以下是模拟并发的代码 TestThread.java 模拟线程12345678910111213141516171819202122232425262728293031import java.util.concurrent.CountDownLatch;public class TestThread implements Runnable &#123; private HelloService hello; private CountDownLatch start; private CountDownLatch finish; private int index; public TestThread(HelloService hello, CountDownLatch start, CountDownLatch finish, int index) &#123; this.hello = hello; this.start = start; this.finish = finish; this.index = index; &#125; @Override public void run() &#123; try &#123; //线程启动后,让所有的线程先等待 start.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; hello.sayHello("name" + index); //方法调用后,计数减1 finish.countDown(); &#125;&#125; HelloService.java 并发请求的接口类123456public class HelloService &#123; public void sayHello(String name) &#123; System.out.println("hello, Mr." + name); &#125;&#125; APP.java 测试类12345678910111213141516171819202122232425262728293031323334import org.apache.commons.lang3.time.StopWatch;public class App &#123; public static void main(String[] args) &#123; HelloService hello = new HelloService(); // 并行度50 int parallel = 50; // 开始计时 StopWatch sw = new StopWatch();// apache下的commons.lang包 sw.start(); // 用于开始 CountDownLatch start = new CountDownLatch(1); // 用于模拟结束 CountDownLatch finish = new CountDownLatch(parallel); for (int index = 0; index &lt; parallel; index++) &#123; TestThread client = new TestThread(hello, start, finish, index); new Thread(client).start(); &#125; // 50个并发线程瞬间发起请求操作 // count 减1变成0，让线程开始工作 start.countDown(); try &#123; // 等待线程执行完成 finish.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; sw.stop(); String tip = String.format("调用总共耗时: [%s] 毫秒", sw.getTime()); System.out.println(tip); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized的使用]]></title>
    <url>%2F2018%2F02%2F02%2Fsynchronized%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言线程安全中需要解决的两个关键点：一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。解决这两个问题需要让线程在执行过程中互斥。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到，这与Volatile关键字的作用一样的。 基本用法synchronized关键字在java中可以修饰于： 实例方法，给当前实例加锁，进入同步代码前要获得当前实例的锁 静态方法，给当前类对象加锁，进入同步代码前要获得当前类对象的锁 代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。 作用于实例方法 实例方法也就是非静态方法，它专属于实例, 不同的实例引用拥有自己独立的实例方法调用权限。换句话说它不是”共享”的，这里共享打引号，意思是可以用这个词去理解它。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class App &#123; public static void main(String[] args) throws InterruptedException &#123; final SyncResource resource = new SyncResource(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; resource.syncIncrease(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; resource.syncIncrease(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(resource.getCount()); &#125;&#125;class SyncResource &#123; private static int i = 0; /** * synchronized作用于实例方法 * @version */ public synchronized void syncIncrease() &#123; i++; &#125; public synchronized void anotherSyncIncrease() &#123; i++; &#125; /** * synchronized作用于静态方法 * * @version */ public synchronized static void syncStaticIncrease() &#123; i++; &#125; public int getCount() &#123; return i; &#125;&#125; 上面的代码中，如果syncIncrease方法不加上synchronized关键字，由于线程1和线程2是并发执行，很有可能两个线程得到的变量i的值并不是上一次i++操作的值，也就是说两个线程对变量的值的变化不可见，导致最终的结果可能小于2000000。加上synchronized之后,由于两个线程持有同一个SyncResource实例,在执行syncIncrease()方法时就会产生互斥,保证线程安全,从而输出最终正确的结果:2000000.需要值得注意的地方是:当一个线程正在访问一个对象的 synchronized 实例方法时，其他线程也将不能访问该对象的其他 synchronized 实例方法（包括synchronized修饰的代码块），毕竟一个对象只有一把锁，但是可以访问该实例对象的其他非synchronized方法修改main方法：1234567891011121314151617181920212223242526272829public static void main(String[] args) throws InterruptedException &#123; final SyncResource resource = new SyncResource(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; resource.syncIncrease(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; //线程调用实例的其它同步实例方法 resource.anotherSyncIncrease(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(resource.getCount());//输出结果也是2000000，很明显两个线程互斥访问了 &#125; 从结果看出，线程对两个实例方法的访问产生互斥，输出了正确的结果。 作用于静态方法当synchronized作用于静态方法时，锁就是当前类的class。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作（注意，后面的代码，如果没有必要我只修改main方法里的调用方式，而SyncResource类和前面一样）。12345678910111213141516171819202122232425public static void main(String[] args) throws InterruptedException &#123;final SyncResource resource = new SyncResource(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; SyncResource.syncStaticIncrease(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; SyncResource.syncStaticIncrease(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(resource.getCount());//输出结果为2000000&#125; 需要注意的是如果一个线程A调用一个实例对象的static synchronized方法，而线程B需要调用这个实例对象所属类的非静态synchronized方法(实例方法)，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁:123456789101112131415161718192021222324252627public static void main(String[] args) throws InterruptedException &#123; final SyncResource resource = new SyncResource(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; SyncResource.syncStaticIncrease(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; //访问非静态方法，不会产生互斥 resource.syncIncrease(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(resource.getCount());//输出结果小于2000000&#125; 作用于代码块synchronized还可以同步代码块，在某些方法中，一些代码块要同步而一些代码不需要同步，这时可以使用synchronized用在需要同步的地方来提高代码的执行效率，同步代码块的使用示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class App &#123; public static void main(String[] args) &#123; final SyncResource resource = new SyncResource(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; resource.syncBlock(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; resource.syncBlock(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(resource.getCount());//输出结果为2000000 &#125; &#125;class SyncResource &#123; private static int i = 0; public void syncBlock() &#123; // 省略不需要同步的代码 // 使用同步代码块对变量i进行同步操作,锁对象为this synchronized (this) &#123; i++; &#125; &#125; public int getCount() &#123; return i; &#125;&#125; 实现原理这里我主要作为基本了解，大概知道底层实现的数据结构就行吧，太深的东西看不明白，看多也也会对自己产生混淆，不用去深追。下面我们使用javap命令来反编译class文件看它的底层实现代码。首先进入到.class文件目录 打开cmd执行：javap -c -v SyncResource得到输出内容（省略了一些信息）:public synchronized void syncIncrease(); flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=2, locals=1, args_size=1 0: getstatic #10 // Field i:I 3: iconst_1 4: iadd 5: putstatic #10 // Field i:I 8: return LineNumberTable: line 98: 0 line 99: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 this Lcom/szc/sync/SyncResource;上面是syncIncrease()方法的反汇编实现，我们可以看到同步方法和其它非同步方法的标志上多了一个ACC_SYNCHRONIZED，JVM就是通过这个标志来区别同步与非同步方法的。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。下面来看代码块的反汇编实现: public void syncBlock(); flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: getstatic #10 // Field i:I 7: iconst_1 8: iadd 9: putstatic #10 // Field i:I 12: aload_1 13: monitorexit 14: goto 20 17: aload_1 18: monitorexit 19: athrow 20: return Exception table: from to target type 4 14 17 any 17 19 17 any LineNumberTable: line 117: 0 line 118: 4 line 117: 12 line 120: 20 LocalVariableTable: Start Length Slot Name Signature 0 21 0 this Lcom/szc/sync/SyncResource;从上面代码可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor ，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。——-这段解释来源于网络^-^,记录下来以后慢慢看。 synchronized的可重入性在java中synchronized是基于原子性的内部锁机制，是可重入的。当一个线程试图操作其他线程持有的对象锁的临界资源时，将会处于阻塞状态,这是当然的，但当一个线程再次请求自己持有对象锁的临界资源时，请求将会成功，这种情况就属于重入锁。123456789101112131415public static void main(String[] args) &#123;final SyncResource resource = new SyncResource(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; resource.syncBlock(); for (int j = 0; j &lt; 1000000; j++) &#123; resource.syncIncrease(); &#125; &#125; &#125;); t1.start(); t1.join(); System.out.println(resource.getCount());//输出结果1000001,可以看到没有产生互斥 &#125; 注意两点： 当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。 由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1。 参考参考资料：https://blog.csdn.net/javazejian/article/details/72828483]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
        <tag>java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[quartz集群datasource使用问题]]></title>
    <url>%2F2018%2F01%2F29%2Fquartz%E9%9B%86%E7%BE%A4datasource%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言我在使用springboot+quartz集群对任务进行持久化过程中，出现了数据库连接问题，在没有增加quartz之前是没有出现过的。错误信息如下： 2018-01-28 10:48:17.170 [QuartzScheduler_schedulerFactoryBean-server-p-532411522141704336_ClusterManager] WARN c.m.v2.c3p0.impl.NewPooledConnection - [c3p0] Another error has occurred [ com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: No operations allowed after connection closed. ] which will not be reported to listeners!com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: No operations allowed after connection closed. at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.7.0_71] at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) ~[na:1.7.0_71] at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.7.0_71] at java.lang.reflect.Constructor.newInstance(Constructor.java:526) ~[na:1.7.0_71] at com.mysql.jdbc.Util.handleNewInstance(Util.java:389) ~[mysql-connector-java-5.1.35.jar:5.1.35] at com.mysql.jdbc.Util.getInstance(Util.java:372) ~[mysql-connector-java-5.1.35.jar:5.1.35] at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:958) ~[mysql-connector-java-5.1.35.jar:5.1.35] at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:937) ~[mysql-connector-java-5.1.35.jar:5.1.35] at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:926) ~[mysql-connector-java-5.1.35.jar:5.1.35] at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:872) ~[mysql-connector-java-5.1.35.jar:5.1.35] at com.mysql.jdbc.ConnectionImpl.throwConnectionClosedException(ConnectionImpl.java:1236) ~[mysql-connector-java-5.1.35.jar:5.1.35] at com.mysql.jdbc.ConnectionImpl.checkClosed(ConnectionImpl.java:1231) ~[mysql-connector-java-5.1.35.jar:5.1.35] at com.mysql.jdbc.ConnectionImpl.setAutoCommit(ConnectionImpl.java:4811) ~[mysql-connector-java-5.1.35.jar:5.1.35] at com.mchange.v2.c3p0.impl.NewProxyConnection.setAutoCommit(NewProxyConnection.java:881) ~[c3p0-0.9.1.1.jar:0.9.1.1] at org.quartz.impl.jdbcjobstore.AttributeRestoringConnectionInvocationHandler.restoreOriginalAtributes(AttributeRestoringConnectionInvocationHandler.java:141) [quartz-2.2.1.jar:na] at org.quartz.impl.jdbcjobstore.JobStoreSupport.cleanupConnection(JobStoreSupport.java:3600) [quartz-2.2.1.jar:na] at org.quartz.impl.jdbcjobstore.JobStoreSupport.doCheckin(JobStoreSupport.java:3286) [quartz-2.2.1.jar:na] at org.quartz.impl.jdbcjobstore.JobStoreSupport$ClusterManager.manage(JobStoreSupport.java:3858) [quartz-2.2.1.jar:na] at org.quartz.impl.jdbcjobstore.JobStoreSupport$ClusterManager.run(JobStoreSupport.java:3895) [quartz-2.2.1.jar:na]Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: The last packet successfully received from the server was 17,145,825 milliseconds ago. The last packet sent successfully to the server was 17,145,825 milliseconds ago. is longer than the server configured value of ‘wait_timeout’. You should consider either expiring and/or testing connection validity before use in your application, increasing the server configured values for client timeouts, or using the Connector/J connection property ‘autoReconnect=true’ to avoid this problem. 排查问题经过网上资料的查找，得到的原因为: 使用dbcp连接池时，没有配置连接的有效验证(validationQuery)。可是我发现我的报错的堆栈信息里是使用的是c3p0的连接池，所以我确定为quartz由于没有指定连接池，使用了默认的c3p0连接池，而默认配置中没有对连接做有效验证，所以报以上错误。那为什么需要对连接进行检查呢？ 原因是这样的：mysql有一个配置项wait_timeout,默认最大timeout时间是8小时，对空闲超过8小时的数据库连接会强行断开,而连接池对此并不感知，从而分配了一个不可用的连接给程序。所以dbcp获取分配连接时，需要对连接验证，如果已经不是正常的连接，则销毁连接，重新分配连接。 解决办法quartz没有指定连接池的解决方案在这里我让quartz使用我之前的datasource,因为我之前的datasource已经对dbcp进行了配置。quartz的配置如下：12345678910111213141516171819202122 @Bean public SchedulerFactoryBean schedulerFactoryBean(@Qualifier("dataSource") DataSource dataSource, Trigger cronJobTrigger) throws IOException &#123;SchedulerFactoryBean factory = new SchedulerFactoryBean();// 用于quartz集群,QuartzScheduler// 启动时更新己存在的Job，这样就不用每次修改targetObject后删除qrtz_job_details表对应记录了factory.setOverwriteExistingJobs(true);// 用于quartz集群,加载quartz数据源// factory.setDataSource(dataSource);// QuartzScheduler 延时启动，应用启动完10秒后 QuartzScheduler 再启动factory.setStartupDelay(10);// 用于quartz集群,加载quartz配置factory.setQuartzProperties(quartzProperties()); //使用指定的datasource，替换掉quartz配置中的xxx.datasource.xxx等配置factory.setDataSource(dataSource);factory.setAutoStartup(true);factory.setApplicationContextSchedulerContextKey("applicationContext");// 注册触发器factory.setTriggers(cronJobTrigger);// factory.setConfigLocation(new// FileSystemResource(this.getClass().getResource("/quartz.properties").getPath()));return factory; &#125; dbcp连接池解决方案 通过设置validationQuery1234567&lt;!-- 配置了这个之后，一定要确保testOnBorrow为true --&gt;&lt;property name="validationQuery"&gt; &lt;value&gt;select 1&lt;/value&gt;&lt;/property&gt; &lt;property name="testOnBorrow"&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; 使用上述配置，连接池在返回数据库连接给申请者时会多执行一条sql语句来确保该连接的有效性。如果数据库方已经关闭了，连接池会重新建立连接并返回给申请者。通过测试似乎跟testWhileIdle没有关系，不管其是true或false都正常工作。 通过配置timeBetweenEvictionRunsMillis和minEvictableIdleTimeMillis12345678&lt;!-- 空闲时间超过半小时的连接 --&gt;&lt;property name="minEvictableIdleTimeMillis"&gt; &lt;value&gt;180000&lt;/value&gt;&lt;/property&gt; &lt;!-- 每隔5分钟检查去检查空闲时间超过minEvictableIdleTimeMillis的连接 --&gt;&lt;property name="timeBetweenEvictionRunsMillis"&gt; &lt;value&gt;300000&lt;/value&gt;&lt;/property&gt; timeBetweenEvictionRunsMillis和minEvictableIdleTimeMillis也不宜设置过小，会加重系统开销。根据具体情况来考虑使用哪种方式。对于数据库可能会经常重启，web应用和数据库机器的网络连接不稳定，可以采取第一种方式，否则使用第二种。由于mysql的默认最大空闲时间8小时，所以只要把minEvictableIdleTimeMillis设置小于此值即可。例如配置每十分钟检查超过空闲一个小时的连接]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>wait_timeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven项目转换成web项目]]></title>
    <url>%2F2018%2F01%2F21%2Fmaven%E9%A1%B9%E7%9B%AE%E8%BD%AC%E6%8D%A2%E6%88%90web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[用maven创建一个webapp的项目时，在eclipse用tomcat容器识别不了，那是因为用maven创建出来的项目不是一个web项目。 解决办法 首先创建一个maven的webapp项目(不要点create a simple project，否则到不了这个页面) 右键工程属性选择”Project Facets” 点击 “Convert faceted form” 勾选Dynamic Web Module 点击Further configuration available…，更改web目录为 “src/main/webapp” 再右键工程属性选择”Deployment Assembly”,把webapp部署到tomcat里,并把依赖添加到WEB-INF/lib下 如果想要更改Context root path，可以右键工程属性选择”Web Project Settings”进行更改 最后用tomcat进行add and remove时就能发现web工程了。]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>webapp</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos安装Node.js]]></title>
    <url>%2F2017%2F06%2F20%2FCentos%E5%AE%89%E8%A3%85Node-js%2F</url>
    <content type="text"><![CDATA[下载源码cd /usr/local/src/wget [https://nodejs.org/dist/v8.10.0/node-v8.10.0.tar.gz] 解压源码tar zxvf node-v0.10.24.tar.gz 进入到node根目录,编译并安装:cd node-v8.10.0./configure –prefix=/usr/local/node/8.10.0make &amp;&amp; make installps:安装这一步时，有可能会耗很多时间 配置NODE_HOME，进入profile编辑环境变量vim /etc/profile设置nodejs环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容:#set for nodejsexport NODE_HOME=/usr/local/node/0.10.24export PATH=$NODE_HOME/bin:$PATH编译/etc/profile 使配置生效:source /etc/profile最后输入：node -v验证是否安装正确 显示v8.10.0则安装正确]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池-基础篇]]></title>
    <url>%2F2017%2F05%2F26%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言 通常情况下，要执行的任务是短暂的，而且任务的数量很大。 为每个任务创建一个新的线程将使系统花费更多的时间创建和销毁线程,却不能保证执行实际的任务。 线程池通过重用现有的线程来解决这个问题并消除了创建新线程的延迟。 适用性 当您有大量的短期任务需要并行执行时,可以考虑用线程池 本文举例 假设有两个任务: 土豆去皮任务和制作咖啡任务,当对这两个任务量化执行时,可以考虑用线程池去完成。 Task.java: 任务抽象类12345678910111213141516171819202122232425public abstract class Task &#123; private static final AtomicInteger ID_GENERATOR = new AtomicInteger(); private final int id; private final int timeMs; public Task(final int timeMs) &#123; this.id = ID_GENERATOR.incrementAndGet(); this.timeMs = timeMs; &#125; public int getId() &#123; return id; &#125; public int getTimeMs() &#123; return timeMs; &#125; @Override public String toString() &#123; return String.format("id=%d timeMs=%d", id, timeMs); &#125;&#125; Worker.java: 任务执行类1234567891011121314151617181920public class Worker implements Runnable &#123; private static final Logger LOGGER = LoggerFactory.getLogger(Worker.class); private final Task task; public Worker(final Task task) &#123; this.task = task; &#125; @Override public void run() &#123; LOGGER.info("&#123;&#125; 正在处理任务: [&#123;&#125;]", Thread.currentThread().getName(), task.toString()); try &#123; Thread.sleep(task.getTimeMs()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; PotatoPeelingTask.java:土豆去皮任务123456789101112131415161718192021/** * * 土豆去皮任务 * */public class PotatoPeelingTask extends Task &#123; /** * 每个土豆去皮的时间 */ private static final int TIME_PER_POTATO = 200; public PotatoPeelingTask(int numPotatoes) &#123; super(numPotatoes * TIME_PER_POTATO); &#125; @Override public String toString() &#123; return String.format("%s %s", this.getClass().getSimpleName(), super.toString()); &#125;&#125; CoffeeMakingTask.java:咖啡制作任务123456789101112131415161718192021/** * * 制作咖啡任务 * */public class CoffeeMakingTask extends Task &#123; /** * 每杯咖啡制作时间 */ private static final int TIME_PER_CUP = 100; public CoffeeMakingTask(int numCups) &#123; super(numCups * TIME_PER_CUP); &#125; @Override public String toString() &#123; return String.format("%s %s", this.getClass().getSimpleName(), super.toString()); &#125;&#125; App.java:程序入口12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) &#123; LOGGER.info("Program started"); // Create a list of tasks to be executed List&lt;Task&gt; tasks = new ArrayList&lt;&gt;(); tasks.add(new PotatoPeelingTask(3)); tasks.add(new PotatoPeelingTask(6)); tasks.add(new CoffeeMakingTask(2)); tasks.add(new CoffeeMakingTask(6)); tasks.add(new PotatoPeelingTask(4)); tasks.add(new CoffeeMakingTask(2)); tasks.add(new PotatoPeelingTask(4)); tasks.add(new CoffeeMakingTask(9)); tasks.add(new PotatoPeelingTask(3)); tasks.add(new CoffeeMakingTask(2)); tasks.add(new PotatoPeelingTask(4)); tasks.add(new CoffeeMakingTask(2)); tasks.add(new CoffeeMakingTask(7)); tasks.add(new PotatoPeelingTask(4)); tasks.add(new PotatoPeelingTask(5)); // Creates a thread pool that reuses a fixed number of threads operating off a shared // unbounded queue. At any point, at most nThreads threads will be active processing // tasks. If additional tasks are submitted when all threads are active, they will wait // in the queue until a thread is available. ExecutorService executor = Executors.newFixedThreadPool(3); // Allocate new worker for each task // The worker is executed when a thread becomes // available in the thread pool for (int i = 0; i &lt; tasks.size(); i++) &#123; Runnable worker = new Worker(tasks.get(i)); executor.execute(worker); &#125; // All tasks were executed, now shutdown executor.shutdown(); while (!executor.isTerminated()) &#123; Thread.yield(); &#125; LOGGER.info("Program finished"); &#125;&#125; 运行结果： 23:33:24.952 [main] INFO com.iluwatar.threadpool.App - Program started23:33:24.968 [pool-1-thread-1] INFO com.iluwatar.threadpool.Worker - pool-1-thread-1 正在处理任务: [PotatoPeelingTask id=1 timeMs=600]23:33:24.968 [pool-1-thread-3] INFO com.iluwatar.threadpool.Worker - pool-1-thread-3 正在处理任务: [CoffeeMakingTask id=3 timeMs=200]23:33:24.968 [pool-1-thread-2] INFO com.iluwatar.threadpool.Worker - pool-1-thread-2 正在处理任务: [PotatoPeelingTask id=2 timeMs=1200]23:33:25.176 [pool-1-thread-3] INFO com.iluwatar.threadpool.Worker - pool-1-thread-3 正在处理任务: [CoffeeMakingTask id=4 timeMs=600]23:33:25.575 [pool-1-thread-1] INFO com.iluwatar.threadpool.Worker - pool-1-thread-1 正在处理任务: [PotatoPeelingTask id=5 timeMs=800]23:33:25.778 [pool-1-thread-3] INFO com.iluwatar.threadpool.Worker - pool-1-thread-3 正在处理任务: [CoffeeMakingTask id=6 timeMs=200]23:33:25.981 [pool-1-thread-3] INFO com.iluwatar.threadpool.Worker - pool-1-thread-3 正在处理任务: [PotatoPeelingTask id=7 timeMs=800]23:33:26.169 [pool-1-thread-2] INFO com.iluwatar.threadpool.Worker - pool-1-thread-2 正在处理任务: [CoffeeMakingTask id=8 timeMs=900]23:33:26.388 [pool-1-thread-1] INFO com.iluwatar.threadpool.Worker - pool-1-thread-1 正在处理任务: [PotatoPeelingTask id=9 timeMs=600]23:33:26.795 [pool-1-thread-3] INFO com.iluwatar.threadpool.Worker - pool-1-thread-3 正在处理任务: [CoffeeMakingTask id=10 timeMs=200]23:33:26.998 [pool-1-thread-1] INFO com.iluwatar.threadpool.Worker - pool-1-thread-1 正在处理任务: [CoffeeMakingTask id=12 timeMs=200]23:33:26.998 [pool-1-thread-3] INFO com.iluwatar.threadpool.Worker - pool-1-thread-3 正在处理任务: [PotatoPeelingTask id=11 timeMs=800]23:33:27.076 [pool-1-thread-2] INFO com.iluwatar.threadpool.Worker - pool-1-thread-2 正在处理任务: [CoffeeMakingTask id=13 timeMs=700]23:33:27.201 [pool-1-thread-1] INFO com.iluwatar.threadpool.Worker - pool-1-thread-1 正在处理任务: [PotatoPeelingTask id=14 timeMs=800]23:33:27.780 [pool-1-thread-2] INFO com.iluwatar.threadpool.Worker - pool-1-thread-2 正在处理任务: [PotatoPeelingTask id=15 timeMs=1000]23:33:28.781 [main] INFO com.iluwatar.threadpool.App - Program finished可以看到,线程池创建了三个线程,并行的执行任务,当有空闲线程时,可以被复用,继续执行任务.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>thread pool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat启动超慢]]></title>
    <url>%2F2017%2F05%2F03%2Ftomcat%E5%90%AF%E5%8A%A8%E8%B6%85%E6%85%A2%2F</url>
    <content type="text"><![CDATA[前段时间在linux上使用tomcat部署项目的时候，启动tomcat没报什么错误，也没仔细看日志，认为启动成功，但是怎么也访问不了我的工程，再仔细看了下tomcat启动日志时，发现如下日志:1WARNING [localhost-startStop-1] org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [269,564] milliseconds. 可以看到生成一个实例会话 ID用了 269,56毫秒，差不多5分钟了。网上查了下资料，大致原因如下： Tomcat 7/8 都使用 org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom 类产生安全随机类 SecureRandom 的实例作&gt;为会话 ID。Tomcat 使用 SHA1PRNG 算法是基于 SHA-1 算法实现且保密性较强的伪随机数生成器。在 SHA1PRNG 中，有一个种子产生器，它根据配置执行各种操作。Linux 中的随机数可以从两个特殊的文件中产生，一个是 /dev/urandom，另外一个是 /dev/random。他们产生随机数的原理是利用当前系统的熵池来计算出固定一定数量的随机比特，然后将这些比特作为字节流返回。熵池就是当前系统的环境噪音，熵指的是一个系统的混乱程度，系统噪音可以通过很多参数来评估，如内存的使用，文件的使用量，不同类型的进程数量等等。如果当前环境噪音变化的不是很剧烈或者当前环境噪音很小，比如刚开机的时候，而当前需要大量的随机比特，这时产生的随机数的随机效果就不是很好了。这就是为什么会有 /dev/urandom 和 /dev/random 这两种不同的文件，后者在不能产生新的随机数时会阻塞程序，而前者不会（ublock），当然产生的随机数效果就不太好了，这对加密解密这样的应用来说就不是一种很好的选择。/dev/random 会阻塞当前的程序，直到根据熵池产生新的随机字节之后才返回，所以使用 /dev/random 比使用 /dev/urandom 产生大量随机数的速度要慢。SecureRandom generateSeed 使用 /dev/random 生成种子。但是 /dev/random 是一个阻塞数字生成器，如果它没有足够的随机数据提供，它就一直等，这迫使 JVM 等待。键盘和鼠标输入以及磁盘活动可以产生所需的随机性或熵。但在一个服务器缺乏这样的活动，可能会出现问题。 解决方法 在Tomcat环境中解决：可以通过配置 JRE 使用非阻塞的 Entropy Source：在 catalina.sh 中加入这么一行：-Djava.security.egd=file:/dev/./urandom 即可。 在 JVM 环境中解决：打开 $JAVA_PATH/jre/lib/security/java.security这个文件,找到下面的内容：securerandom.source=file:/dev/random替换成：securerandom.source=file:/dev/./urandom。一定要注意是 urandom。如果不知道JAVA_PATH在哪可以使用linux命令：$ whereis java查看。我的JAVA_PATH在/usr/java/jdk1.8.0_161]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>SecureRandom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA责任链模式]]></title>
    <url>%2F2017%2F03%2F25%2FJAVA%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 责任链模式是由命令对象和一系列处理对象组成的设计模式。 每个处理对象都包含用于定义它可以处理的命令对象类型的逻辑; 其余的被传递给链中的下一个处理对象。 也可以将新的处理对象添加到该链的末尾。简单的说就是:请求从一端进入并继续从一个对象到对象，直到找到合适的处理程序。 适用性什么情况下使用责任链 一个请求被多个对象处理时,处理对象事先对请求并不可知，需要处理程序自动确定。 多个对象之一发出请求，而无需明确指定接收者。 可以动态地指定 可处理请求的对象集合。 经典案例 java.util.logging.Logger#log() Apache Commons Chain javax.servlet.Filter#doFilter() 本文举例 兽人之王向他的军队发出大声的命令。 最接近的反应是指挥官，然后是军官，然后是士兵。 这里的指挥官，军官和士兵形成了一个责任链。 OrcKing.java12345678910111213141516171819202122232425/** * 兽人国王做出 请求链 */public class OrcKing &#123; //责任链 RequestHandler chain; public OrcKing() &#123; buildChain(); &#125; private void buildChain() &#123; //分别由兽人命令官——&gt;兽人长官——&gt;兽人士兵 去执行 chain = new OrcCommander(new OrcOfficer(new OrcSoldier(null))); &#125; /** * 下达命令 * @param req */ public void makeRequest(Request req) &#123; chain.handleRequest(req); &#125;&#125; RequestHandler.java1234567891011121314151617181920212223242526272829303132333435363738/** * RequestHandler */public abstract class RequestHandler &#123; private static final Logger LOGGER = LoggerFactory.getLogger(RequestHandler.class); //下一个处理对象 private RequestHandler next; /* * 构造函数应该传入下一个需要处理的handler * @param handler */ public RequestHandler(RequestHandler next) &#123; this.next = next; &#125; /** * Request handler */ public void handleRequest(Request req) &#123; //如果下一个对象不为空,则交由下一个对象处理 if (next != null) &#123; next.handleRequest(req); &#125; &#125; protected void printHandling(Request req) &#123; LOGGER.info("&#123;&#125; 正在处理请求 \"&#123;&#125;\"", this, req); &#125; /** *每个对象需要的处理的逻辑 */ @Override public abstract String toString();&#125; Request.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 请求 */public class Request &#123; /** * 请求类型 */ private final RequestType requestType; /** * 请求描述 */ private final String requestDescription; /** * 是否处理请求。 请求只能将状态从未处理状态切换到已处理状态，无法“解除”处理请求 */ private boolean handled; /** * 构造函数 * @param requestType * The type of request * @param requestDescription * The description of the request */ public Request(final RequestType requestType, final String requestDescription) &#123; this.requestType = Objects.requireNonNull(requestType); this.requestDescription = Objects.requireNonNull(requestDescription); &#125; /** * Get a description of the request * * @return A human readable description of the request */ public String getRequestDescription() &#123; return requestDescription; &#125; /** * Get the type of this request, used by each person in the chain of command to * see if they should or can handle this particular request * * @return The request type */ public RequestType getRequestType() &#123; return requestType; &#125; /** * 标记为已经处理 */ public void markHandled() &#123; this.handled = true; &#125; /** * @return &lt;tt&gt;true&lt;/tt&gt; when the request is handled, &lt;tt&gt;false&lt;/tt&gt; if not */ public boolean isHandled() &#123; return this.handled; &#125; @Override public String toString() &#123; return getRequestDescription(); &#125;&#125; RequestType.java12345678910/** * * RequestType enumeration * */public enum RequestType &#123; //防御城堡，处理囚犯，收取税款 DEFEND_CASTLE, TORTURE_PRISONER, COLLECT_TAX&#125; OrcCommander.java12345678910111213141516171819202122232425262728/** * 兽人指挥官 */public class OrcCommander extends RequestHandler &#123; /* * 构造函数应该传入下一个需要处理的handler * @param handler */ public OrcCommander(RequestHandler handler) &#123; super(handler); &#125; @Override public void handleRequest(Request req) &#123; if (req.getRequestType().equals(RequestType.DEFEND_CASTLE)) &#123; printHandling(req); req.markHandled(); &#125; else &#123; super.handleRequest(req); &#125; &#125; @Override public String toString() &#123; return "兽人指挥官"; &#125;&#125; OrcOfficer.java12345678910111213141516171819202122232425/** * 兽人军官 */public class OrcOfficer extends RequestHandler &#123; public OrcOfficer(RequestHandler handler) &#123; super(handler); &#125; @Override public void handleRequest(Request req) &#123; if (req.getRequestType().equals(RequestType.TORTURE_PRISONER)) &#123; printHandling(req); req.markHandled(); &#125; else &#123; super.handleRequest(req); &#125; &#125; @Override public String toString() &#123; return "兽人军官"; &#125;&#125; OrcSoldier.java1234567891011121314151617181920212223242526/** * * 兽人士兵 * */public class OrcSoldier extends RequestHandler &#123; public OrcSoldier(RequestHandler handler) &#123; super(handler); &#125; @Override public void handleRequest(Request req) &#123; if (req.getRequestType().equals(RequestType.COLLECT_TAX)) &#123; printHandling(req); req.markHandled(); &#125; else &#123; super.handleRequest(req); &#125; &#125; @Override public String toString() &#123; return "兽人士兵"; &#125;&#125; App.java123456789101112131415public class App &#123; /** * Program entry point * * @param args command line args */ public static void main(String[] args) &#123; OrcKing king = new OrcKing(); king.makeRequest(new Request(RequestType.DEFEND_CASTLE, "防御城堡")); king.makeRequest(new Request(RequestType.TORTURE_PRISONER, "处理囚犯")); king.makeRequest(new Request(RequestType.COLLECT_TAX, "收取税款")); &#125;&#125; 运行结果： 20:31:25.194 [main] INFO com.iluwatar.chain.RequestHandler - 兽人指挥官 正在处理请求 "防御城堡" 20:31:25.199 [main] INFO com.iluwatar.chain.RequestHandler - 兽人军官 正在处理请求 "处理囚犯" 20:31:25.199 [main] INFO com.iluwatar.chain.RequestHandler - 兽人士兵 正在处理请求 "收取税款"]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>chain</tag>
        <tag>责任链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT使用笔记]]></title>
    <url>%2F2017%2F03%2F24%2FGIT%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[初始化工程 在Git官网上点击New repository新建项目 在本地新建一个同名文件。 打开git bash切换到新建的文件目录 新建一个README文件并写入内容echo "# myprojectname">>README.md 生成“.gitignore”文件。touch .gitignore写入 :.settings/target/.classpath.project.class git初始化git init 将全部文件添加到git中 git add . #添加当前目录下的所有文件 git add README.md #只添加README.md文件 提交，-m参数添加注释git commit -m "commit message" 创建远程仓库origin git remote add origin git@github.com:shizhengchao/hello.git 如果出现: fatal: remote origin already exists. 说明远程仓库已经存在,如果想重新生成，执行git remote rm origin后，再新增。如果不想重新生成,则不用管,直接跳过这一步就行。 push代码更新远程仓库git push -u origin master 9和10可以合并为:git push git@github.com:shizhengchao/hello.git master 常用操作 删除远程仓库中的文件和文件夹 git rm --cached ./xxx/xxx.log #删除文件 git rm -r --cached ./xxx/log/ #删除文件夹 clone工程 git clone xxx.git #完整的拉取git仓库里的工程 pull git pull #远程获取最新版本并merge（合并）到本地 问题 unable to access ‘https://github.com/shizhengchao/spring-boot-all.git/&#39;: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 env命令设置GIT_SSL_NO_VERIFY环境变量为”ture” $ env GIT_SSL_NO_VERIFY=true]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令记录]]></title>
    <url>%2F2017%2F03%2F20%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[基本命令 查看目录 [root@izbp1311i2pe1xiq3x174lz home]# ls [root@izbp1311i2pe1xiq3x174lz home]# ll [root@izbp1311i2pe1xiq3x174lz home]# ll -a #显示所有文件 比如在用vim编写文件时，由于没有退出保存，导致下一次编辑时被锁住，可以用此命令找到.xxxx.swp文件，删除此文件即可重新编辑 查看磁盘使用情况 df -h 查看当前目录下的所有目录的使用情况 du -h --max-depth=1 #参数 --max-depth=1代表目录深度 找出当前目录下及子目录下的大于800M的文件 find . -type f -size +800M -print 删除包含子目录的所有文件 rm -rf xxx #-f强制删除，-r删除目录; 创建文件夹 mkdir folder 复制abc.log文件到/dir目录下 cp abc.log /dir/ 移动或者重命名文件 mv abc.log /dir #把abc.log移到 /dir目录下 mv abc.log def.log #把abc.log重命名为def.log 显示文件行数 wc -l abc.log #显示abc.log中有多少行 comm按行来比较两个排序文件 如果两个文件顺序不一样,请用sort命令排序后覆盖原文件再排序 vim a.txt 111 222 333 vim b.txt 333 444 555 comm -1 a.txt b.txt #除去文件a中的唯一行 333 444 555 comm -2 a.txt b.txt #除去b中的唯一行 111 222 333 comm -12 a.txt b.txt #取交集 333 comm -3 a.txt b.txt #除去a b两个文件中相同的行,输出不同的行 111 222 444 555 日志方面 监控最后400行日志文件的变化 tail -400f demo.log 在文件demo.log中查找所有包行INFO的行grep 'INFO' demo.log #还可以加参数显示前后多少行-B 前 -A 后 -C 前后 -o选项只提取order-fix.curr_id:xxx的内容（而不是一整行），并输出到屏幕上grep -o 'order-fix.curr_id:[0-9]\+' demo.log 网络方面 查看redis连接数netstat -nat|grep -i "6379"|wc -l 查看端口6379 连接数losf -i:6379 wget和curlGET请求 使用curl curl “http://www.baidu.com” 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地 curl -i “http://www.baidu.com” 显示全部信息 curl -l “http://www.baidu.com” 只显示头部信息 curl -v “http://www.baidu.com” 显示get请求全过程解析 使用wget命令 wget “http://www.baidu.com” post请求 使用curl命令 curl -d "param1=value1& param2=value2" "http://www.baidu.com" #通过-d参数，把访问参数放在里面 使用wget命令 wget --post-data "user=foo& password=bar" http://www.baidu.com #--post-data参数来实现 直接发送格式化请求 curl -H "Content-type: application/json" -X POST -d '{"srcRef":"1002"}'http://fsc-inner.99bill.com/acs/deposit/1002]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA重写hashCode通用方法(摘录自《Effective Java》)]]></title>
    <url>%2F2017%2F02%2F15%2FJAVA%E9%87%8D%E5%86%99hashCode%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95-%E6%91%98%E5%BD%95%E8%87%AA%E3%80%8AEffective-Java%E3%80%8B%2F</url>
    <content type="text"><![CDATA[初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17; 选取equals方法中用于比较的所有域，然后针对每个域的属性进行计算： (1) 如果是boolean值，则计算flag ? 1:0(2) 如果是byte\char\short\int,则计算(int)f(3) 如果是long值，则计算(int)(f ^ (f &gt;&gt;&gt; 32))(4) 如果是float值，则计算Float.floatToIntBits(f) (5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0。简单的说就是直接调用对象的hashcode()。(7) 如果是数组，那么需要为每个元素当做单独的域来处理。如果你使用的是1.5及以上版本的JDK，那么没必要自己去重新遍历一遍数组，java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上，其中long[]的为: 1234567891011public static int hashCode(long a[]) &#123; if (a == null)&#123; return 0; &#125; int result = 1; for (long element : a) &#123; int elementHash = (int) (element ^ (element &gt;&gt;&gt; 32)); result = 31 * result + elementHash; &#125; return result; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>hashcode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Builder设计模式]]></title>
    <url>%2F2017%2F01%2F15%2FBuilder%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 将复杂的对象从其构造中分离出来，用于使相同的构造过程可以产生不同的引用。简单的说就是:允许您创建不同风格的对象，同时避免构造器污染。 用于 有几种风格的对象时 或者当创建对象时涉及很多步骤时。 适用性什么情况下需要Builder the algorithm for creating a complex object should be independent of the parts that make up the object and how they’re assembled（google翻译….:用于创建复杂对象的算法应该独立于构成对象的部件以及它们的组装方式) the construction process must allow different representations for the object that’s constructed(google翻译….:允许不同的引用对象拥有相同的构造过程) 经典案例 java.lang.StringBuilder java.nio.ByteBuffer 以及类似的缓冲区，如FloatBuffer，IntBuffer等等 java.lang.StringBuffer All implementations of java.lang.Appendable Apache Camel builders 本文举例 想象一下角色扮演游戏的角色生成器。 最简单的选择是让电脑为你创造角色。 但是，如果你想选择职业，性别，头发颜色等字符细节，字符生成将成为一个循序渐进的过程，当所有选择都准备就绪时，就完成了。 Hero.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Hero, the class with many parameters. */public final class Hero &#123; //职业 private final Profession profession; private final String name; private final HairType hairType; private final HairColor hairColor; //装备 private final Armor armor; private final Weapon weapon; //getter setter..... private Hero(Builder builder) &#123; this.profession = builder.profession; this.name = builder.name; this.hairColor = builder.hairColor; this.hairType = builder.hairType; this.weapon = builder.weapon; this.armor = builder.armor; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append("This is a ").append(profession).append(" named ").append(name); if (hairColor != null || hairType != null) &#123; sb.append(" with "); if (hairColor != null) &#123; sb.append(hairColor).append(' '); &#125; if (hairType != null) &#123; sb.append(hairType).append(' '); &#125; sb.append(hairType != HairType.BALD ? "hair" : "head"); &#125; if (armor != null) &#123; sb.append(" wearing ").append(armor); &#125; if (weapon != null) &#123; sb.append(" and wielding a ").append(weapon); &#125; sb.append('.'); return sb.toString(); &#125; /** * The builder class. */ public static class Builder &#123; private final Profession profession; private final String name; private HairType hairType; private HairColor hairColor; private Armor armor; private Weapon weapon; /** * Constructor */ public Builder(Profession profession, String name) &#123; if (profession == null || name == null) &#123; throw new IllegalArgumentException("profession and name can not be null"); &#125; this.profession = profession; this.name = name; &#125; public Builder withHairType(HairType hairType) &#123; this.hairType = hairType; return this; &#125; public Builder withHairColor(HairColor hairColor) &#123; this.hairColor = hairColor; return this; &#125; public Builder withArmor(Armor armor) &#123; this.armor = armor; return this; &#125; public Builder withWeapon(Weapon weapon) &#123; this.weapon = weapon; return this; &#125; public Hero build() &#123; return new Hero(this); &#125; &#125;&#125; Profession.java1234567891011121314/** * * Profession enumeration * */public enum Profession &#123; WARRIOR, THIEF, MAGE, PRIEST; @Override public String toString() &#123; return name().toLowerCase(); &#125;&#125; HairType.java123456789101112131415161718192021/** * * HairType enumeration * */public enum HairType &#123; BALD("bald"), SHORT("short"), CURLY("curly"), LONG_STRAIGHT("long straight"), LONG_CURLY( "long curly"); private String title; HairType(String title) &#123; this.title = title; &#125; @Override public String toString() &#123; return title; &#125;&#125; HairColor.java1234567891011121314/** * * HairColor enumeration * */public enum HairColor &#123; WHITE, BLOND, RED, BROWN, BLACK; @Override public String toString() &#123; return name().toLowerCase(); &#125;&#125; Armor.java1234567891011121314151617181920/** * * Armor enumeration * */public enum Armor &#123; CLOTHES("clothes"), LEATHER("leather"), CHAIN_MAIL("chain mail"), PLATE_MAIL("plate mail"); private String title; Armor(String title) &#123; this.title = title; &#125; @Override public String toString() &#123; return title; &#125;&#125; Weapon.java1234567891011121314/** * * Weapon enumeration * */public enum Weapon &#123; DAGGER, SWORD, AXE, WARHAMMER, BOW; @Override public String toString() &#123; return name().toLowerCase(); &#125;&#125; App.java1234567891011121314151617181920212223242526272829public class App &#123; private static final Logger LOGGER = LoggerFactory.getLogger(App.class); /** * Program entry point * * @param args command line args */ public static void main(String[] args) &#123; Hero mage = new Hero.Builder(Profession.MAGE, "Riobard").withHairColor(HairColor.BLACK) .withWeapon(Weapon.DAGGER).build(); LOGGER.info(mage.toString()); Hero warrior = new Hero.Builder(Profession.WARRIOR, "Amberjill").withHairColor(HairColor.BLOND) .withHairType(HairType.LONG_CURLY).withArmor(Armor.CHAIN_MAIL).withWeapon(Weapon.SWORD) .build(); LOGGER.info(warrior.toString()); Hero thief = new Hero.Builder(Profession.THIEF, "Desmond").withHairType(HairType.BALD) .withWeapon(Weapon.BOW).build(); LOGGER.info(thief.toString()); &#125;&#125; 源码出处推荐一个学习设置模式的github项目https://github.com/iluwatar/java-design-patterns.git]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>builder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客]]></title>
    <url>%2F2017%2F01%2F03%2FHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[准备工作在开始一切之前，你必须已经： 有一个github账号 安装了node.js、npm 点击这里查看教程 安装了git 本文所使用的环境： Centos7.0 node v8.10.0 hexo-cli: 1.1.0 git version 1.8.3.1 搭健github仓库创建仓库 新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了 绑定域名 当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问。但如果要绑定域名,首先你要注册一个域名，我是用阿里的万网注册的绑定域名分2种情况：带www和不带www的。域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下：然后到你的xxx.github.io仓库的设置里面绑定域名： 配置SSH key 在使用git提交或者拉取代码时，每次都要输入用户名和密码，可以配置SSH key以跳过这个步骤。1$ cd ~/. ssh #检查本机已存在的ssh密钥,如果提示：No such file or directory 说明你是第一次使用git 再输入如下命令1ssh-keygen -t rsa -C &quot;shizhengchao@outlook.com&quot; #后面这个是自己注册github的邮箱地址 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，打开并复制里面的内容1cd ~/.ssh/ 打开你的github主页，进入个人设置(点右上角头像倒三角那里) -&gt; SSH and GPG keys -&gt; New SSH key,将刚复制的内容粘贴到key那里，title随便填，保存。 输入如下命令测试是否配置成功，如果出现:Hi shizhengchao! You’ve successfully authenticated, but GitHub does not provide shell access.则配置成功1ssh -T git@github.com #第一次会有一个提示,输入yes 最后配置全局的用户名和邮箱地址12git config --global user.name &quot;shizhengchao&quot;// 你的github用户名，非昵称git config --global user.email &quot;shizhengchao@outlook.com&quot;// 填写你的github注册邮箱 搭建Hexo安装Heox1234567npm install hexo-cli -g #安装hexo-clicd /home/workspace hexo init hexoblog #初始化一个目录cd hexoblognpm install #生成目录结构hexo ghexo server #启动hexo 浏览器打开 [http://localhost:4000], 就可以看到如下默认主题: 下载github上的内容12cd sourcegit clone https://github.com/shizhengchao/shizhengchao.github.io.git 安装好hexo后,如果是第一次搭建的github.io，那么只有一个CNAME文件把CNAME文件clone到source里123cd source/shizhengchao.github.io.gitmv CNAME ../rm -rf shizhengchao.github.io.git 如果不是第一次搭建github.io，也就是说你已经写了一些博客了，在另一台电脑上使用hexo，除了把CNAME移到source里, 还要先删除public里的所有内容,再把shizhengchao.github.io.git全部移到public里1234cd source/shizhengchao.github.io.gitmv CNAME ../ #这里如果还有其它自己的静态文件也一起移到外面去mv * ../../public/rm -rf shizhengchao.github.io.git 更换主题 下载yilia主题, 下载的主题都在themes目录里12cd /home/workspace/hexobloggit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexoblog目录下的_config.yml, 把theme换成yilia,deploy也改成git123456theme: yiliadeploy: type: git repo: git@github.com:shizhengchao/shizhengchao.github.io.git #注意这里如果配置成了ssh就要这样写 branch: maste 上传到github 安装hexo-deployer插件，然后部署1234npm install hexo-deployer-git --savehexo cleanhexo g # 如果你在source里加了东西或者改了主题里的_config.yml，要执行下这个命令.hexo d #上传到github 最后试着在浏览器打开你绑定的域名，就可以看到效果了, 推荐一个比较好的写hexo博客的插件hexo-admin，网上资料比较多，按着官网就能完成安装，所以这里就不再多说.]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[I hear and I forget. I see and I remember. I do and I understand]]></content>
  </entry>
</search>
